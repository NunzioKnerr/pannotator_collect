[
  {
    "objectID": "goproMaxStills2KmzConverter.html",
    "href": "goproMaxStills2KmzConverter.html",
    "title": "gopro max stills 2 kmz converter",
    "section": "",
    "text": "This workflow creates a .kmz file from geocoded 360° images taken with a GoPro Max. It involves package setup, file renaming, selecting images by distance (20m default), adding overlays (optional), creating a .kml file, then finally converting everything to a .kmz file for use in the pannotator package for annotating. To use this script open the pannotator_collect.Rproj in RStudio, then open this file (goproMaxStills2 KmzConverter.qmd) and run each code chunk in order to create a .kmz file."
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#tldr",
    "href": "goproMaxStills2KmzConverter.html#tldr",
    "title": "gopro max stills 2 kmz converter",
    "section": "",
    "text": "This workflow creates a .kmz file from geocoded 360° images taken with a GoPro Max. It involves package setup, file renaming, selecting images by distance (20m default), adding overlays (optional), creating a .kml file, then finally converting everything to a .kmz file for use in the pannotator package for annotating. To use this script open the pannotator_collect.Rproj in RStudio, then open this file (goproMaxStills2 KmzConverter.qmd) and run each code chunk in order to create a .kmz file."
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#description-of-the-workflow",
    "href": "goproMaxStills2KmzConverter.html#description-of-the-workflow",
    "title": "gopro max stills 2 kmz converter",
    "section": "Description of the Workflow",
    "text": "Description of the Workflow\nThis workflow has been developed to allow easy creation of .kmz files from 360 degree panospheric images. These can be taken with a gopro Max camera or most consumer drones like those made by DJI. The overlay may need to be adjusted depending on the size of the images generated etc.\nAny geocoded equirectangular images (jpegs) can be used, regardless of how they were created, but this workflow is specifically tailored to the gopro Max.\nBefore using this script we recommend making a backup of the original camera files just in case as this script edits the files directly.\nThe workflow code below is as follows:\n\nCheck and install required packages\nSet user options:\n&gt; folder containing 360 degree images (jpgs)\n&gt; distance between images (metres)\n&gt; add overlays (True/False)\n&gt; overlay file to use (png with transparency)\nRename the files (only renames files if names are 12 characters long)\nGet subset of images a specified distance apart (defaults to 20m)\nAdd overlays to the images (optional)\nCreate a google earth .kml file\nConvert the kml file and associated images into a single .kmz file\n\nThe resulting .kmz file can then be used in the pannotator package for annotating."
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#check-install-required-packages",
    "href": "goproMaxStills2KmzConverter.html#check-install-required-packages",
    "title": "gopro max stills 2 kmz converter",
    "section": "Check & Install Required Packages",
    "text": "Check & Install Required Packages\nIn order for this workflow to function as expected there are a few dependent packages to install and configure. If you are on linux or mac you may have some issues with the ‘magick’ package, check the documentation here.\nOn Linux you need to install the ImageMagick++ library: on Debian/Ubuntu this is called libmagick++-dev:\nsudo apt-get install libmagick++-dev\nTo install from source on macOS you need either imagemagick@6 or imagemagick from homebrew.\nbrew install imagemagick@6\nIn RStudio use the play arrow at the top-right corner of the chunks to run them.\n\n\nShow the code\ndependentPackages &lt;-\n  c(\"svDialogs\",\n    \"stringr\",\n    \"tools\",\n    \"exiftoolr\",\n    \"geosphere\",\n    \"stringr\",\n    \"gpx\",\n    \"magick\",\n    \"imager\",\n    \"fs\",\n    \"magrittr\",\n    \"zip\",\n    \"usefun\"\n  )\n\nfor (i in dependentPackages) {\n  print(paste0(\"Checking for: \", i))\n  \n  # First check if you have the package installed\n  check_for_package &lt;- system.file(package = i)\n  print(check_for_package)\n  \n  # If not run the following code to install it.\n  if (check_for_package == \"\") {\n    print(paste0(i, \" package not found .....installing now\"))\n    install.packages(i)\n  } else {\n    print(paste0(i, \" package is already installed\"))\n  }\n}"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#set-user-options-manual-version",
    "href": "goproMaxStills2KmzConverter.html#set-user-options-manual-version",
    "title": "gopro max stills 2 kmz converter",
    "section": "Set User Options (manual version)",
    "text": "Set User Options (manual version)\nHere we manually set the user options which will be used in the following code chunks\n\n\nShow the code\n# Manually add the path: use forward slashed only. (Windows)\n# directory &lt;- \"C:/FolderContaining360Images/\"\n# Manually add the path: use forward slashes only (works for macOS and Linux).\n directory &lt;- \"C:/E/gitRepos/pannotator_collect/gopro_images\"\n\n# Select the minimum distance in metres between each extracted image.\n metresBetweenEachImageWanted &lt;- 100\n\n# Set to TRUE to add overlays to each image file; or FALSE to use images without any overlays.\n addOverlays &lt;- TRUE\n\n# Conditionally set the overlay image file if addOverlays is TRUE\nif (addOverlays == TRUE) {\n  # specify file path manually.\n   overlayImageFile &lt;- \"./overlay_files/5m_overlay_wedges_straight6.png\"\n} else if (identical(addOverlays, FALSE) || length(addOverlays) == 0) {\n  overlayImageFile &lt;- NULL\n}"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#set-user-options-svdialog-gui-version",
    "href": "goproMaxStills2KmzConverter.html#set-user-options-svdialog-gui-version",
    "title": "gopro max stills 2 kmz converter",
    "section": "Set User Options (svDialog GUI version)",
    "text": "Set User Options (svDialog GUI version)\nHere we set the user options using GUI popups which will be used in the following code chunks\n\n\nShow the code\n# svDialogs::msgBox(\"There will be several popup dialogs so you can select the different options\")\n# \n# # Choose the directory path containing 360 images.\n# directory &lt;- svDialogs::dlg_dir(default = getwd(), title = \"Select Directory Containing 360 images\")$res\n# \n# # Select the minimum distance in metres between each extracted image.\n# metresBetweenEachImageWanted &lt;- svDialogs::dlg_input(message = \"Enter a value for: metresBetweenEachImageWanted\", default = \"100\")$res\n# \n# # Set to TRUE to add overlays to each image file; or FALSE to use images without any overlays.\n# addOverlays &lt;- svDialogs::dlgList(choices=c(TRUE,FALSE), preselect = TRUE, multiple = FALSE, title = \"Add overlay to images?\")$res\n# \n# # Conditionally set the overlay image file if addOverlays is TRUE\n# if (addOverlays == TRUE) {\n#   # Choose the file for your desired overlay image (PNG image with transparency).\n#   overlayImageFile &lt;- svDialogs::dlg_open(default = \"./overlay_files\", title = \"Select overlay file (png)\", multiple = FALSE, filters = svDialogs::dlg_filters[\"png\", ])$res\n# } else if (identical(addOverlays, FALSE) || length(addOverlays) == 0) {\n#   overlayImageFile &lt;- NULL\n#   }\n# \n# finalMessage &lt;- paste0(\"Folder with 360 Images: \", directory,\n#    \" Metres Between Each Image Wanted: \", metresBetweenEachImageWanted, \" AddOverlays: \", addOverlays)\n# if (addOverlays == TRUE) {\n#   finalMessage &lt;- paste0(finalMessage, \" Overlay Image File: \" , overlayImageFile)\n# }\n# \n# svDialogs::dlg_message(message =finalMessage, type = \"ok\")"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#rename-files",
    "href": "goproMaxStills2KmzConverter.html#rename-files",
    "title": "gopro max stills 2 kmz converter",
    "section": "Rename Files",
    "text": "Rename Files\nBy default most consumer cameras like the gopro max & DJI drones don’t allow the user to specify the file names they apply to images that they create.\nA typical file name follows the format GS__XXXX.JPG - where XXXX is a counter number of the images taken by the camera.\nTo address this issue and make it easier to manage the files for processing, this code pre-pends the date_time stamp to the beginning of the files in a given directory. It’s useful for organising files when doing field work, especially when using multiple cameras at the same time.\nThe output format is: YYYYMMDD_HHMMSS_FileName.ext\nNote: Gopro now have a custom firmware allowing you to set file names in the field; see this GoPro Labs link.\nThis code checks the file name length initially assuming that files names directly downloaded from the camera are 12 characters long. If the files used have longer file names they will not be renamed. This ensures they are only renamed once.\n\n\nShow the code\nlibrary(exiftoolr)\nlibrary(stringr)\nlibrary(tools)\n\n# Check if 'directory' is set and valid, throw an error if not\nif (!exists(\"directory\") || !dir.exists(paste0(directory)) || length(directory) == 0) {\n  stop(\"'directory' does not exist. Please run the code chunk under 'Set User Options' above to set the directory containing the 360 images.\"\n  )\n}\n\n# filter only .jpg or .JPG files\nfile_extension &lt;- \"\\\\.[Jj][Pp][Gg]$\"\n\nmy_files &lt;-\n  list.files(\n    directory,\n    pattern = paste0(\"*\", file_extension),\n    all.files = FALSE,\n    full.names = TRUE\n  )\n\n#read the exif information in the file to get the creation date\nfiles_df &lt;- exiftoolr::exif_read(my_files, args = c(\"-G1\", \"-a\", \"-s\"))\n\n#Loop through the files and check to change file names\n#this checks if the files have already been changed by looking at the length of the file name.\nfor (i in 1:nrow(files_df)) {\n  print(\"Checking if camera file name has not been changed\")\n  if (nchar(files_df[i, \"System:FileName\"]) == 12) {\n    print(\"File appears to be 12 characters long\")\n    print(paste0(\"SourceFile: \", files_df[i, \"SourceFile\"]))\n    origFullFileName &lt;- paste0(files_df[i, \"SourceFile\"])\n    createDate &lt;- paste0(files_df[i, \"ExifIFD:DateTimeOriginal\"])\n    print(paste0(\"CreateDate: \", createDate))\n    formattedCreateDate &lt;- stringr::str_replace_all(createDate, \":\", \"\")\n    formattedCreateDate &lt;- stringr::str_replace_all(formattedCreateDate, \" \", \"_\")\n    print(paste0(\"formattedCreateDate: \", formattedCreateDate))\n    file_ext &lt;- tolower(tools::file_ext(files_df[i, \"System:FileName\"]))\n    newFileName &lt;- paste0(files_df[i, \"System:Directory\"], \"/\", formattedCreateDate,\"_\",tools::file_path_sans_ext(basename(files_df[i, \"System:FileName\"])), \".\",file_ext)\n    print(paste0(\"newFileName: \", newFileName))\n    file.rename(from = origFullFileName, to = newFileName)\n    print(\"File name changed\")\n  } else {\n    print(\n      \"It appears that the file has already been renamed as it's greater than 12 characters long\"\n    )\n    print(paste0(\"SourceFile: \", files_df[i, \"SourceFile\"]))\n  }\n  \n}"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#function-to-calculate-distances-between-image-geo-locations.",
    "href": "goproMaxStills2KmzConverter.html#function-to-calculate-distances-between-image-geo-locations.",
    "title": "gopro max stills 2 kmz converter",
    "section": "Function to calculate distances between image geo-locations.",
    "text": "Function to calculate distances between image geo-locations.\nThis code looks through all the files in a given folder and copies images a user-specified distance apart into a new folder for use later on. It starts with the first file and looks for a file at least XX metres from that. Once it finds one it adds it to the list then uses it as the location to look for another file at least XX metres from it and so on until it gets to the end of the file list. This method is most suitable for linear transect sampling but should work with any images that are spaced out enough.\n\n\nShow the code\nlibrary(geosphere)\n\noptions(digits = 20)\noptions(digits.secs = 20)\noptions(scipen = 9999)\n\n#function which takes 2 arguments\n#1:gpx_locations - a dataframe containing 4 columns(\"SourceFile\", \"System:Directory\", \"Composite:GPSLongitude\", \"Composite:GPSLatitude\")\n#2:distance in metres between each image to extract. (default=20m)\nfindImagesEveryXmetres &lt;-\n  function(my_gpx_locs, metresToNextImage = 20) {\n    gpx_locs &lt;- my_gpx_locs\n    \n    keeps &lt;- c(\"Composite:GPSLongitude\", \"Composite:GPSLatitude\")\n    points &lt;- gpx_locs[keeps]\n    \n    #View(points)\n    #View(gpx_locs)\n    \n    #calculate the distance between any two points\n    distance_m &lt;- geosphere::distm(points , fun = geosphere::distHaversine)\n    rownames(distance_m) &lt;- basename(gpx_locs[, \"SourceFile\"])\n    colnames(distance_m) &lt;- basename(gpx_locs[, \"SourceFile\"])\n    \n    #View(distance_m)\n    \n    #find images a certain distance apart.\n    selected_files &lt;- vector()\n    \n    metres_between_images &lt;- metresToNextImage\n    \n    print(paste0(\n      \"Searching for images apart by: \",\n      metres_between_images,\n      \" metres\"\n    ))\n    \n    for (i in 1:nrow(distance_m)) {\n      if (i == 1) {\n        #if it is the first frame add it as the current frame\n        selected_files &lt;-\n          append(selected_files, rownames(distance_m)[i])\n        current_frame &lt;- rownames(distance_m)[i]\n        print(paste0(\"Frame 1: \", current_frame))\n        print(paste0(\n          \"looking for frame &gt;\",\n          metres_between_images ,\n          \" Metres from frame 1\"\n        ))\n      }#if the current frame is greater than the specified metres\n      if ((distance_m[i, current_frame] &gt; metres_between_images)) {\n        current_frame &lt;- rownames(distance_m)[i]\n        print(paste0(\"current_frame: \", current_frame))\n        selected_files &lt;- append(selected_files, current_frame)\n      }\n      \n    }\n    print(paste0(\"Files found:\", selected_files))\n    \n    new_folder &lt;-\n      paste0(gpx_locs[1, \"System:Directory\"], \"_\", metres_between_images, \"m_apart\")\n    \n    dir.create(new_folder)\n    \n    source_folder &lt;-  dirname(gpx_locs[1, \"SourceFile\"])\n    \n    print(gpx_locs[1, \"System:Directory\"])\n    \n    for (q in selected_files) {\n      file_to_copy &lt;- paste0(source_folder, \"/\", q)\n      destination &lt;- paste0(new_folder,  \"/\", q)\n      file.copy(\n        file_to_copy,\n        destination,\n        overwrite = TRUE,\n        recursive = FALSE,\n        copy.mode = TRUE,\n        copy.date = TRUE\n      )\n    }\n    \n  }\n\nprint(\"findImagesEveryXmetres(my_gpx_locs, metresToNextImage) function is now available to call\")"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#call-function-above",
    "href": "goproMaxStills2KmzConverter.html#call-function-above",
    "title": "gopro max stills 2 kmz converter",
    "section": "Call Function Above",
    "text": "Call Function Above\nNow call the function above to calculate the distance between all the images and copy them to a new folder.\n\n\nShow the code\nlibrary(exiftoolr)\n\n# Check if 'directory' is set and valid, throw an error if not\nif (!exists(\"directory\") || !dir.exists(paste0(directory)) || length(directory) == 0) {\n  stop(\"'directory' does not exist. Please run the code chunk under 'Set User Options' above to set the directory containing the 360 images.\"\n  )\n}\n\nfile_extension &lt;- \"\\\\.[Jj][Pp][Gg]$\"\n\nmy_files &lt;-\n  list.files(\n    directory,\n    pattern = paste0(file_extension),\n    all.files = FALSE,\n    full.names = TRUE\n  )\n\nimage_files_df &lt;-\n  exiftoolr::exif_read(my_files, args = c(\"-G1\", \"-a\", \"-s\"))\n\n#View(image_files_df)\n\ngpx_locs &lt;-\n  as.data.frame(image_files_df[, c(\n    \"SourceFile\",\n    \"System:Directory\",\n    \"Composite:GPSLatitude\",\n    \"Composite:GPSLongitude\"\n  )])\n\n#View(gpx_locs)\n\nif (!exists(\"metresBetweenEachImageWanted\") || length(metresBetweenEachImageWanted) == 0) {\n  print(\"'metresBetweenEachImageWanted' does not exist. Using Default value. Please run the code chunk under 'Set User Options' above if you want to change the metresBetweenEachImageWanted\")\n  findImagesEveryXmetres(my_gpx_locs = gpx_locs)\n} else {\n  findImagesEveryXmetres(my_gpx_locs = gpx_locs, metresToNextImage = metresBetweenEachImageWanted)\n}"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#add-overlays-to-the-images-magick",
    "href": "goproMaxStills2KmzConverter.html#add-overlays-to-the-images-magick",
    "title": "gopro max stills 2 kmz converter",
    "section": "Add Overlays to the Images (magick)",
    "text": "Add Overlays to the Images (magick)\nThis code goes through the images in the folder created above and adds the overlay file to them. This overlay must be specific to the camera used to create the 360 degree images as the focal length of the lens etc. will define how the overlay should look.\nIn this example we used a gopro Max at 3.2m above the ground. The easiest way to determine how an overlay should look is to take some images with the camera at the specified height with the desired overlay marked on the ground so you have an easy template to base your overlay on.\nHere we wanted a circular marker with a 5 metre radius and we were lucky to find a round concrete water tank buried in the ground with the required radius. We marked the distance in metres from the centre of the plot directly under the camera using a pole with black marking tape at 1 metre intervals. Below is the image loaded into inkscape so we could draw the required marker lines for the overlay.\n\n\n\noverlay image with camera background\n\n\nNote: There is a slight discrepancy with the line on the right side of the image. This is due to the camera not being exactly vertical when capturing the image.\nThe overlay was created using inkscape and then exported as a portable network graphics (.png) file with transparency. See the example below:\n\n\n\noverlay image with transparency\n\n\nThe code below uses imagemagick to load the underlying base file and then overlays the .png and saves out the flattened file for use in the kml/kmz files in the following steps. If you are on linux and have issues with the ‘magick’ package you may need to up the memory settings in the /etc/ImageMagick-6/policy.xml file.\n&lt;policy domain=\"resource\" name=\"memory\" value=\"4GiB\"/&gt; \n&lt;policy domain=\"resource\" name=\"map\" value=\"8GiB\"/&gt; \n&lt;policy domain=\"resource\" name=\"disk\" value=\"16GiB\"/&gt; \n&lt;policy domain=\"resource\" name=\"area\" value=\"10GiB\"/&gt; \nYou can find more info on how to do this here.\n\n\nShow the code\nlibrary(magick)\nlibrary(tools)\nlibrary(magrittr)\n\n# Check if 'directory' is set and valid, throw an error if not\nif (!exists(\"directory\") || !dir.exists(paste0(directory)) || length(directory) == 0) {\n  stop(\"'directory' does not exist. Please run the code chunk under 'Set User Options' above to set the directory containing the 360 images.\"\n  )\n}\n\n# if 'metresBetweenEachImageWanted' doesn't exist then add the default metres between images\nif (!exists(\"metresBetweenEachImageWanted\") || length(metresBetweenEachImageWanted) == 0) {\n  print(\"'metresBetweenEachImageWanted' not selected...using default: Please run the code chunk under 'Set User Options' above to set the metresBetweenEachImageWanted.\"\n  )\n  metresBetweenEachImageWanted &lt;- 20\n}\n\n# if 'addOverlays' doesn't exist then throw an error asking to set 'addOverlays'\nif (!exists(\"addOverlays\") || length(addOverlays) == 0) {\n  stop(\"'addOverlays' does not exist. Please run the code chunk under 'Set User Options' above to set the addOverlays.\")\n}\n\nif (addOverlays == TRUE) {\n  overlay_file &lt;- overlayImageFile\n  \n  new_directory &lt;-  paste0(directory,\n                           \"_\",\n                           metresBetweenEachImageWanted,\n                           \"m_apart\")\n  \n  if (!dir.exists(paste0(new_directory))) {\n    print(paste0(new_directory, \" does not exist!\"))\n  stop(\"Did you run the code chunk above to find images a certain distance apart?\"\n  )\n}\n  # first create a new directory to add the overlay images to\n  dir.create(paste0(new_directory, \"/with_overlay/\"))\n  \n  file_extension &lt;- \"\\\\.[Jj][Pp][Gg]$\"\n  \n  files_lst &lt;-\n    list.files(\n      new_directory,\n      pattern = paste0(file_extension),\n      all.files = FALSE,\n      full.names = TRUE,\n      recursive = FALSE,\n      include.dirs = FALSE\n    )\n  \n  \n  for (t in 1:length(files_lst)) {\n    background_image &lt;- magick::image_read(files_lst[t])\n    overlay &lt;-\n      magick::image_read(overlay_file)\n    image_dir &lt;- dirname(files_lst[t])\n    overlay_image_dir &lt;- paste0(image_dir, \"/with_overlay/\")\n    new_filename &lt;-\n      paste0(overlay_image_dir,\n             basename(tools::file_path_sans_ext(files_lst[t])),\n             \"_with_overlay.jpg\")\n    print(paste0(\"Adding overlay to create: \", new_filename))\n    img &lt;- c(background_image, overlay) %&gt;%\n      magick::image_flatten(.) %&gt;%\n      magick::image_write(., new_filename, format = \"jpg\")\n  }\n  \n} else {\n  print(\"'addOverlays' not TRUE: No overlay files generated\")\n}"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#overlays-to-the-images-imager",
    "href": "goproMaxStills2KmzConverter.html#overlays-to-the-images-imager",
    "title": "gopro max stills 2 kmz converter",
    "section": "Overlays to the Images (imager)",
    "text": "Overlays to the Images (imager)\nThis code is an alternative version in case you have problems loading the magick package\n\n\nShow the code\n# library(imager)\n# \n# # Check if 'directory' is set and valid, throw an error if not\n# if (!exists(\"directory\") || !dir.exists(paste0(directory)) || length(directory) == 0) {\n#   stop(\"'directory' does not exist. Please run the code chunk under 'Set User Options' above to set the directory containing the 360 images.\"\n#   )\n# }\n# \n# # if 'metresBetweenEachImageWanted' doesn't exist then add the default metres between images\n# if (!exists(\"metresBetweenEachImageWanted\") || length(metresBetweenEachImageWanted) == 0) {\n#   print(\"'metresBetweenEachImageWanted' not selected...using default: Please run the code chunk under 'Set User Options' above to set the metresBetweenEachImageWanted.\"\n#   )\n#   metresBetweenEachImageWanted &lt;- 20\n# }\n# \n# # if 'addOverlays' doesn't exist then throw an error asking to set 'addOverlays'\n# if (!exists(\"addOverlays\") || length(addOverlays) == 0) {\n#   stop(\"'addOverlays' does not exist. Please run the code chunk under 'Set User Options' above to set the addOverlays.\")\n# }\n# \n# if (addOverlays == TRUE) {\n#   overlay_file &lt;- overlayImageFile\n#   \n#   new_directory &lt;-  paste0(directory,\n#                            \"_\",\n#                            metresBetweenEachImageWanted,\n#                            \"m_apart\")\n#   \n#   if (!dir.exists(paste0(new_directory))) {\n#     print(paste0(new_directory, \" does not exist!\"))\n#   stop(\"Did you run the code chunk above to find images a certain distance apart?\"\n#   )\n# }\n#   # first create a new directory to add the overlay images to\n#   dir.create(paste0(new_directory, \"/with_overlay/\"))\n#   \n#   file_extension &lt;- \"\\\\.[Jj][Pp][Gg]$\"\n#   \n#   files_lst &lt;-\n#     list.files(\n#       new_directory,\n#       pattern = paste0(file_extension),\n#       all.files = FALSE,\n#       full.names = TRUE,\n#       recursive = FALSE,\n#       include.dirs = FALSE\n#     )\n#  \n#   for (t in 1:length(files_lst)) {\n# \n#     base_image &lt;- imager::load.image(files_lst[t])\n#     overlay &lt;-  imager::load.image(overlay_file)\n#     \n#     # Resize overlay to match the dimensions of the base image (if needed)\n#     overlay_resized &lt;- resize(overlay, dim(base_image)[1], dim(base_image)[2])\n#     \n#     # Add the overlay onto the base image\n#     # Ensure the overlay has an alpha channel for transparency\n#     if (dim(overlay_resized)[4] == 4) {\n#         # Extract RGB channels from the base image\n#         base_rgb &lt;- base_image[,,,1:3]\n#   \n#         # Extract RGB and alpha channels from the overlay\n#         overlay_rgb &lt;- overlay_resized[,,,1:3]\n#         alpha &lt;- overlay_resized[,,,4]\n#   \n#         #print(dim(base_rgb))    # Dimensions of base image's RGB channels\n#         #print(dim(overlay_rgb)) # Dimensions of overlay's RGB channels\n#         #print(dim(alpha))       # Dimensions of overlay's alpha channel\n# \n#         alpha &lt;- abind::abind(alpha, alpha, alpha, along = 3)\n#   \n#         # Blend the overlay with the base image using the alpha channel\n#         blended_image &lt;- (base_rgb * (1 - alpha)) + (overlay_rgb * alpha)\n#     }\n#     \n#     image_dir &lt;- dirname(files_lst[t])\n#     overlay_image_dir &lt;- paste0(image_dir, \"/with_overlay/\")\n#     new_filename &lt;-\n#       paste0(overlay_image_dir,\n#              basename(tools::file_path_sans_ext(files_lst[t])),\n#              \"_with_overlay.jpg\")\n#     print(paste0(\"Adding overlay to create: \", new_filename))\n#     \n#     # Save the result\n#     imager::save.image(imager::as.cimg(blended_image), new_filename)\n#   }\n#   \n# } else {\n#   print(\"'addOverlays' not TRUE: No overlay files generated\")\n# }"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#imager-single-image",
    "href": "goproMaxStills2KmzConverter.html#imager-single-image",
    "title": "gopro max stills 2 kmz converter",
    "section": "Imager Single Image",
    "text": "Imager Single Image\n\n\nShow the code\n#library(imager)\n\n# # Load the base image (e.g., a 360-degree image)\n# base_image &lt;- load.image(\"gopro_images_100m_apart/20220807_161152_GS020327.jpg\")\n# \n# #plot(base_image)\n# # Load the overlay image (e.g., a PNG with transparency)\n# overlay &lt;- load.image(\"overlay_files/5m_overlay_wedges_straight6.png\")\n# \n# #plot(overlay)\n# # Resize overlay to match the dimensions of the base image (if needed)\n# overlay_resized &lt;- resize(overlay, dim(base_image)[1], dim(base_image)[2])\n# \n# # Add the overlay onto the base image\n# # Ensure the overlay has an alpha channel for transparency\n# if (dim(overlay_resized)[4] == 4) {\n#   # Extract RGB channels from the base image\n#   base_rgb &lt;- base_image[,,,1:3]\n#   \n#   # Extract RGB and alpha channels from the overlay\n#   overlay_rgb &lt;- overlay_resized[,,,1:3]\n#   alpha &lt;- overlay_resized[,,,4]\n#   \n#   print(dim(base_rgb))    # Dimensions of base image's RGB channels\n#   print(dim(overlay_rgb)) # Dimensions of overlay's RGB channels\n#   print(dim(alpha))       # Dimensions of overlay's alpha channel\n# \n#   alpha &lt;- abind::abind(alpha, alpha, alpha, along = 3)\n#   \n#   # Blend the overlay with the base image using the alpha channel\n#   blended_image &lt;- (base_rgb * (1 - alpha)) + (overlay_rgb * alpha)\n# }\n# \n# # Save the result\n# save.image(as.cimg(blended_image), \"test_output_image.jpg\")\n\n# Display the image\n#plot(as.cimg(blended_image))"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#generate-kml-file",
    "href": "goproMaxStills2KmzConverter.html#generate-kml-file",
    "title": "gopro max stills 2 kmz converter",
    "section": "Generate kml File",
    "text": "Generate kml File\nThis code generates a google earth kml file linking to the image files in the folder generated above. It uses ExifTool with a template “kml_hide_rollover.fmt” to create the kml file.\n\n\nShow the code\nlibrary(readr)\n\n# Check if 'directory' is set and valid, throw an error if not\nif (!exists(\"directory\") || !dir.exists(paste0(directory)) || length(directory) == 0) {\n  stop(\"'directory' does not exist. Please run the code chunk under 'Set User Options' above to set the directory containing the 360 images.\"\n  )\n}\n\n# if 'metresBetweenEachImageWanted' doesn't exist then add the default metres between images\nif (!exists(\"metresBetweenEachImageWanted\") || length(metresBetweenEachImageWanted) == 0) {\n  print(\"'metresBetweenEachImageWanted' not selected...using default: Please run the code chunk under 'Set User Options' above to set the metresBetweenEachImageWanted.\"\n  )\n  metresBetweenEachImageWanted &lt;- 20\n}\n\nif (addOverlays == TRUE) {\n\nnew_directory &lt;-\n  paste0(directory,\n         \"_\",\n         metresBetweenEachImageWanted,\n         \"m_apart/with_overlay\")\n\noutput_kml &lt;-\n   normalizePath(paste0(directory,\n         \"_\",\n         metresBetweenEachImageWanted,\n         \"m_apart_with_overlay.kml\"), winslash = \"/\", mustWork = FALSE)\n} else if(addOverlays == FALSE || length(addOverlays) == 0) {\n  new_directory &lt;-\n  paste0(directory,\n         \"_\",\n         metresBetweenEachImageWanted,\n         \"m_apart\")\n\noutput_kml &lt;-\n  normalizePath(paste0(directory,\n         \"_\",\n         metresBetweenEachImageWanted,\n         \"m_apart.kml\"), winslash = \"/\", mustWork = FALSE)\n}\n\nexif_args &lt;- c(\"-p\", \"kml_hide_rollover.fmt\", \"-r\")\nexiftoolr::exif_call(\n  args = exif_args,\n  path = new_directory,\n  stdout = output_kml,\n  quiet = FALSE\n)\n\n# now fix the links to the images to make them relative.\nmystring &lt;- readr::read_file(output_kml)\npath_only &lt;- paste0(dirname(output_kml))\nmystring2 &lt;- gsub(path_only, \".\", mystring, fixed = T)\n\n# Write the file out\nsink(paste0(output_kml))\n  writeLines(mystring2)\nsink()\n\nprint(paste0(\"generated kml file: \", output_kml))"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#convert-.kml-images-into-a-.kmz-file",
    "href": "goproMaxStills2KmzConverter.html#convert-.kml-images-into-a-.kmz-file",
    "title": "gopro max stills 2 kmz converter",
    "section": "Convert .kml & Images into a .kmz File",
    "text": "Convert .kml & Images into a .kmz File\nThis code reads the .kml file created above and converts it to a .kmz file. This involves zipping up the images and the .kml file into one file. It also edits the relative links etc. The convenience of the kmz file is that it combines the kml and associated images into one file.\nNOTE: This code can generate kmz files &gt;2GB. These files won’t open correctly in google earth but are not corrupt and will work fine in pannotator. This is a limitation of google earth being 32 bit. You can read about it here.\n\n\nShow the code\nlibrary(fs)\nlibrary(usefun)\nlibrary(readr)\nlibrary(stringr)\nlibrary(zip)\n\n# Check if 'directory' is set and valid, throw an error if not\nif (!exists(\"directory\") || !dir.exists(paste0(directory)) || length(directory) == 0) {\n  stop(\"'directory' does not exist. Please run the code chunk under 'Set User Options' above to set the directory containing the 360 images.\"\n  )\n}\n\n# if 'metresBetweenEachImageWanted' doesn't exist then add the default metres between images\nif (!exists(\"metresBetweenEachImageWanted\") || length(metresBetweenEachImageWanted) == 0){\n  print(\"'metresBetweenEachImageWanted' not selected...using default: Please run the code chunk under 'Set User Options' above to set the metresBetweenEachImageWanted.\"\n  )\n  metresBetweenEachImageWanted &lt;- 20\n}\n\nif (addOverlays == TRUE) {\n\nnew_directory &lt;-\n  paste0(directory,\n         \"_\",\n         metresBetweenEachImageWanted,\n         \"m_apart/with_overlay\")\n\noutput_kml &lt;-\n  normalizePath(paste0(directory,\n         \"_\",\n         metresBetweenEachImageWanted,\n         \"m_apart_with_overlay.kml\"), winslash = \"/\", mustWork = FALSE)\n} else if(addOverlays == FALSE || length(addOverlays) == 0) {\n  new_directory &lt;-\n  paste0(directory,\n         \"_\",\n         metresBetweenEachImageWanted,\n         \"m_apart\")\n\noutput_kml &lt;-\n  normalizePath(paste0(directory,\n         \"_\",\n         metresBetweenEachImageWanted,\n         \"m_apart.kml\"), winslash = \"/\", mustWork = FALSE)\n}\n\nprint(\"Generating kmz file for:\")\nprint(output_kml)\n\nkml_file_name &lt;- basename(output_kml)\nkml_image_directory &lt;- new_directory\n\ndir_to_copy &lt;- normalizePath(kml_image_directory, winslash = \"/\", mustWork = FALSE)\ntemp_folder &lt;- paste0(usefun::get_parent_dir(directory), \"temp\")\nnew_dir_path &lt;- paste0(temp_folder, \"/files/\")\n\nfs::dir_copy(dir_to_copy, new_dir_path, overwrite = TRUE)\nfs::file_copy(output_kml, temp_folder, overwrite = TRUE)\nfile.rename(\n  from = file.path(temp_folder, kml_file_name),\n  to = file.path(temp_folder, \"doc.kml\")\n)\n\n#clean up all of the extra line breaks in the kml file\nmystring &lt;- readr::read_file(file.path(temp_folder, \"doc.kml\"))\nmystring2 &lt;- gsub('\\r\\r\\r\\r\\r\\n', '\\n', mystring, fixed = T)\nmystring3 &lt;- gsub('\\r\\r\\r\\r\\n', '\\n', mystring2, fixed = T)\nmystring4 &lt;- gsub('\\r\\r\\r\\n', '\\n', mystring3, fixed = T)\nmystring5 &lt;- gsub('\\r\\r\\n', '\\n', mystring4, fixed = T)\nmystring6 &lt;- gsub('\\n\\r\\n', ' ', mystring5, fixed = T)\n\n# Extract the part of the string after the last '/'\n\nif (addOverlays == TRUE) {\nlast_part_dir &lt;- tail(strsplit(dir_to_copy, \"/\")[[1]], 2)\nmykml &lt;-\n  stringr::str_replace_all(mystring6[1], paste0(\"src='./\", last_part_dir[1],\"/\", last_part_dir[2]), \"src='files\")\n}  else if(addOverlays == FALSE) {\n  last_part_dir &lt;- tail(strsplit(dir_to_copy, \"/\")[[1]], 2)\nmykml &lt;-\n  stringr::str_replace_all(mystring6[1], paste0(\"src='./\", last_part_dir[2]), \"src='files\")\n}\n\nmykml &lt;- stringr::str_replace_all(mykml[1], \"&lt;name&gt;./\", \"&lt;name&gt;\")\nsink(paste0(file.path(temp_folder, \"doc.kml\")))\nwriteLines(mykml)\nsink()\n\n# name for new kmz file\nkmz_file_name &lt;-\n  paste0(usefun::get_parent_dir(directory),\"/\",\n         basename(tools::file_path_sans_ext(output_kml)),\n         \".kmz\")\n\n# create the kmz file\nmyWd &lt;- normalizePath(temp_folder, winslash = \"/\", mustWork = FALSE)\nfiles_lst &lt;-\n  list.files(\n    path = temp_folder,\n    pattern = \"*.jpg|*.kml\",\n    all.files = FALSE,\n    full.names = FALSE,\n    recursive = TRUE,\n    ignore.case = FALSE,\n    include.dirs = FALSE\n  )\n\n# zip the file up\nzip::zip(\n  kmz_file_name,\n  files_lst,\n  recurse = FALSE,\n  compression_level = 9,\n  include_directories = TRUE,\n  root = myWd,\n  mode = \"mirror\"\n)\n\n# remove the temp folder and its contents\nunlink(temp_folder, recursive = TRUE)"
  }
]