[
  {
    "objectID": "goproMaxStills2KmzConverter.html",
    "href": "goproMaxStills2KmzConverter.html",
    "title": "gopro max stills 2 kmz converter",
    "section": "",
    "text": "This workflow has been developed to allow easy creation of .kmz files from 360 panospheric images.\nThese can be taken with a gopro Max camera or most consumer drones like those made by DJI.\nAny geocoded equirectangular images (jpegs) can be used, regardless of how they were created.\nThe workflow is as follows:\n\nRename the files (this renames your original files, we suggest making a backup before using the workflow)\nGet subset of images a specified distance apart\nAdd overlays to the images\nCreate a google earth .kml file\nConvert the kml file and associated images into a single .kmz file\n\nThe resulting .kmz file can then be used in the pannotator package for annotating."
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#description-of-the-workflow",
    "href": "goproMaxStills2KmzConverter.html#description-of-the-workflow",
    "title": "gopro max stills 2 kmz converter",
    "section": "",
    "text": "This workflow has been developed to allow easy creation of .kmz files from 360 panospheric images.\nThese can be taken with a gopro Max camera or most consumer drones like those made by DJI.\nAny geocoded equirectangular images (jpegs) can be used, regardless of how they were created.\nThe workflow is as follows:\n\nRename the files (this renames your original files, we suggest making a backup before using the workflow)\nGet subset of images a specified distance apart\nAdd overlays to the images\nCreate a google earth .kml file\nConvert the kml file and associated images into a single .kmz file\n\nThe resulting .kmz file can then be used in the pannotator package for annotating."
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#check-install-dependent-packages",
    "href": "goproMaxStills2KmzConverter.html#check-install-dependent-packages",
    "title": "gopro max stills 2 kmz converter",
    "section": "Check & Install Dependent Packages",
    "text": "Check & Install Dependent Packages\nIn order for this workflow to function as expected there are a few dependent packages to install and configure.\n\n\nShow the code\ndependentPackages &lt;-\n  c(\"tcltk\",\n    \"stringr\",\n    \"tools\",\n    \"exiftoolr\",\n    \"geosphere\",\n    \"stringr\",\n    \"gpx\",\n    \"magick\",\n    \"fs\",\n    \"magrittr\",\n    \"plotKML\",\n    \"zip\",\n    \"usefun\"\n  )\n\nfor (i in dependentPackages) {\n  print(paste0(\"Checking for: \", i))\n  \n  # First check if you have the package installed\n  check_for_package &lt;- system.file(package = i)\n  print(check_for_package)\n  \n  # If not run the following code to install it.\n  if (check_for_package == \"\") {\n    print(paste0(i, \" package not found .....installing now\"))\n    install.packages(i)\n  } else {\n    print(paste0(i, \" package is already installed\"))\n  }\n}"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#rename-files",
    "href": "goproMaxStills2KmzConverter.html#rename-files",
    "title": "gopro max stills 2 kmz converter",
    "section": "Rename Files",
    "text": "Rename Files\nBy default most consumer cameras like the gopro max & DJI drones don’t allow the user to specify the file names they apply to images that they create.\nA typical file name follows the format GS__XXXX.JPG - where XXXX is a counter number of the images taken by the camera.\nTo address this issue and make it easier to manage the files for processing, this code appends the date_time stamp to the beginning of the files in a given directory. It’s useful for organising files when doing field work, especially when using multiple cameras at the same time.\nThe output format is: YYYYMMDD_HHMMSS_FileName.ext\nNote: Gopro now have custom firmware that allows you to set the filenames in the field see this GoPro Labs link.\nThis code checks the file name length initially assuming that files names directly downloaded from the camera are 12 characters long. If the files used have longer file names they will not be renamed. This ensures they are only renamed once.\n\n\nShow the code\nlibrary(tcltk)\nlibrary(exiftoolr)\n\n#This code uses tcltk to throw up a folder browser window for the user to select the directory with the gopro max files to be renamed\ndirectory &lt;-\n  tcltk::tk_choose.dir(default = \"gopro_images\", caption = \"Select directory with files to process\")\n#OR\n#directory &lt;- \"C:/FolderToUse/\"\n#file_extension &lt;- \"\\\\.JPG$\"\nfile_extension &lt;- \"\\\\.[Jj][Pp][Gg]$\"\n\nmy_files &lt;-\n  list.files(\n    directory,\n    pattern = paste0(\"*\", file_extension),\n    all.files = FALSE,\n    full.names = TRUE\n  )\n\n#read the exif information in the file to get the creation date\nfiles_df &lt;-\n  exiftoolr::exif_read(my_files, args = c(\"-G1\", \"-a\", \"-s\"))\n\n#Loop through the files and check to change files names\n#this checks if the files have already been changed by looking at the length of the file name.\nfor (i in 1:nrow(files_df)) {\n  print(\"Checking if camera file name has not been changed\")\n  if (nchar(files_df[i, \"System:FileName\"]) == 12) {\n    print(\"File appears to be 12 characters long\")\n    print(paste0(\"SourceFile: \", files_df[i, \"SourceFile\"]))\n    origFullFileName &lt;- paste0(files_df[i, \"SourceFile\"])\n    createDate &lt;- paste0(files_df[i, \"ExifIFD:DateTimeOriginal\"])\n    print(paste0(\"CreateDate: \", createDate))\n    formattedCreateDate &lt;- stringr::str_replace_all(createDate, \":\", \"\")\n    formattedCreateDate &lt;- stringr::str_replace_all(formattedCreateDate, \" \", \"_\")\n    print(paste0(\"formattedCreateDate: \", formattedCreateDate))\n    file_ext &lt;- tolower(tools::file_ext(files_df[i, \"System:FileName\"]))\n    newFileName &lt;- paste0(files_df[i, \"System:Directory\"], \"/\", formattedCreateDate,\"_\",tools::file_path_sans_ext(basename(files_df[i, \"System:FileName\"])), \".\",file_ext)\n    print(paste0(\"newFileName: \", newFileName))\n    file.rename(from = origFullFileName, to = newFileName)\n    print(\"File name changed\")\n  } else {\n    print(\n      \"It appears that the files have already been renamed as it's greater than 12 characters long\"\n    )\n    print(paste0(\"SourceFile: \", files_df[i, \"SourceFile\"]))\n  }\n  \n}"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#function-to-calculate-distances-between-image-geo-locations.",
    "href": "goproMaxStills2KmzConverter.html#function-to-calculate-distances-between-image-geo-locations.",
    "title": "gopro max stills 2 kmz converter",
    "section": "Function to calculate distances between image geo-locations.",
    "text": "Function to calculate distances between image geo-locations.\nThis code looks through all the files in a given folder and copies images a user-specified distance apart into a new folder for use later on. It starts with the first file and looks for a file at least XX metres from that. Once it finds one it adds it to the list then uses it as the location to look for another file at least XX metres from it and so on until it gets to the end of the file list. This method is most suitable for linear transect sampling.\n\n\nShow the code\nlibrary(geosphere)\n\noptions(digits = 20)\noptions(digits.secs = 20)\noptions(scipen = 9999)\n\n#function which takes 2 arguments\n#1:gpx_locations - a dataframe containing 4 columns(\"SourceFile\", \"System:Directory\", \"Composite:GPSLongitude\", \"Composite:GPSLatitude\")\n#2:distance in metres between each image to extract. (default=50m)\nfindImagesEveryXmetres &lt;-\n  function(my_gpx_locs, metresToNextImage = 50) {\n    gpx_locs &lt;- my_gpx_locs\n    \n    keeps &lt;- c(\"Composite:GPSLongitude\", \"Composite:GPSLatitude\")\n    points &lt;- gpx_locs[keeps]\n    \n    #View(points)\n    #View(gpx_locs)\n    \n    #calculate the distance between any two points\n    distance_m &lt;- geosphere::distm(points , fun = geosphere::distHaversine)\n    rownames(distance_m) &lt;- basename(gpx_locs[, \"SourceFile\"])\n    colnames(distance_m) &lt;- basename(gpx_locs[, \"SourceFile\"])\n    \n    #View(distance_m)\n    \n    #find images a certain distance apart.\n    selected_files &lt;- vector()\n    \n    metres_between_images &lt;- metresToNextImage\n    \n    print(paste0(\n      \"Searching for images apart by: \",\n      metres_between_images,\n      \" metres\"\n    ))\n    \n    for (i in 1:nrow(distance_m)) {\n      if (i == 1) {\n        #if it is the first frame add it as the current frame\n        selected_files &lt;-\n          append(selected_files, rownames(distance_m)[i])\n        current_frame &lt;- rownames(distance_m)[i]\n        print(paste0(\"Frame 1: \", current_frame))\n        print(paste0(\n          \"looking for frame &gt;\",\n          metres_between_images ,\n          \" Metres from frame 1\"\n        ))\n      }#if the current frame is greater than the specified metres\n      if ((distance_m[i, current_frame] &gt; metres_between_images)) {\n        current_frame &lt;- rownames(distance_m)[i]\n        print(paste0(\"current_frame: \", current_frame))\n        selected_files &lt;- append(selected_files, current_frame)\n      }\n      \n    }\n    print(paste0(\"Files found:\", selected_files))\n    \n    new_folder &lt;-\n      paste0(gpx_locs[1, \"System:Directory\"], \"_Frames_\", metres_between_images, \"m_apart\")\n    \n    dir.create(new_folder)\n    \n    source_folder &lt;-  dirname(gpx_locs[1, \"SourceFile\"])\n    \n    print(gpx_locs[1, \"System:Directory\"])\n    \n    for (q in selected_files) {\n      file_to_copy &lt;- paste0(source_folder, \"/\", q)\n      destination &lt;- paste0(new_folder,  \"/\", q)\n      file.copy(\n        file_to_copy,\n        destination,\n        overwrite = TRUE,\n        recursive = FALSE,\n        copy.mode = TRUE,\n        copy.date = TRUE\n      )\n    }\n    \n  }"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#call-function-above",
    "href": "goproMaxStills2KmzConverter.html#call-function-above",
    "title": "gopro max stills 2 kmz converter",
    "section": "Call Function Above",
    "text": "Call Function Above\nNow call the function above to calculate the distance between all the images and copy them to a new folder\n\n\nShow the code\nif (!exists(\"directory\")) {\n  directory &lt;-\n    tcltk::tk_choose.dir(default = \"\", caption = \"Select directory with files to process\")\n}\n\nfile_extension &lt;- \"\\\\.jpg$\"\n\nmy_files &lt;-\n  list.files(\n    directory,\n    pattern = paste0(file_extension),\n    all.files = FALSE,\n    full.names = TRUE\n  )\n\nimage_files_df &lt;-\n  exiftoolr::exif_read(my_files, args = c(\"-G1\", \"-a\", \"-s\"))\n\n#View(image_files_df)\n\ngpx_locs &lt;-\n  as.data.frame(image_files_df[, c(\n    \"SourceFile\",\n    \"System:Directory\",\n    \"Composite:GPSLatitude\",\n    \"Composite:GPSLongitude\"\n  )])\n\n#View(gpx_locs)\n\nmetresBetweenEachImageWanted &lt;- 1\n\nfindImagesEveryXmetres(my_gpx_locs = gpx_locs, metresToNextImage = metresBetweenEachImageWanted)"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#add-overlays-to-the-images",
    "href": "goproMaxStills2KmzConverter.html#add-overlays-to-the-images",
    "title": "gopro max stills 2 kmz converter",
    "section": "Add Overlays to the Images",
    "text": "Add Overlays to the Images\nThis code goes through the images in the folder created above and adds the overlay file to them. This overlay must be specific to the camera used to create the 360 images as the focal length of the lens etc. will define how the overlay should look.\nIn this example we used a gopro Max at 3.2m above the ground. The easiest way to determine how an overlay should look is to take some images with the camera at the specified height with the desired overlay marked on the ground so you have an easy template to base your overlay on.\nHere we wanted a circular marker at a 5 metre radius and we were lucky to find a round concrete water tank buried in the ground with the required radius. We marked the distance in metres from the centre of the plot directly under the camera using a pole with black marking tape at 1 metre intervals. Below is the image loaded into inkscape so we could draw the required marker lines for the overlay.\n\n\n\noverlay image with camera background\n\n\nNote: There is a slight discrepancy with the line on the right side of the image. This is due to the camera not being exactly vertical when capturing the image.\nThe overlay was created using inkscape and the exported as a portable network graphics (.png) file with transparency. See the example below:\n\n\n\noverlay image with transparency\n\n\nThe code below uses imagemagick to load the underlying base file and then overlays the .png and saves out the flattened file for use in the kml/kmz files in the following steps.\n\n\nShow the code\nlibrary(magick)\nlibrary(tools)\n\nif (!exists(\"directory\")) {\n  directory &lt;-\n    tcltk::tk_choose.dir(default = \"\", caption = \"Select directory with files to process\")\n  #OR\n  #directory &lt;- \"C:/folder_path_to_gopro_files/\"\n}\n\n# if it doesn't exist then add the default metres between images\nif (!exists(\"metresBetweenEachImageWanted\")) {\n  metresBetweenEachImageWanted &lt;- 50\n}\n\n# if it doesn't exist then thorw up a dialog to select the overlay file to use\nif (!exists(\"overlay_file\")) {\n  overlay_file &lt;-  tcltk::tk_choose.files(default= \"./overlay_files/5m_overlay_wedges_straight6.png\", caption = \"Select the overlay .png to use\", multi=FALSE)\n}\n\nnew_directory &lt;-\n  paste0(directory,\n         \"_Frames_\",\n         metresBetweenEachImageWanted,\n         \"m_apart\")\n\nfile_extension &lt;- \"\\\\.jpg$\"\n\nfiles_lst &lt;-\n  list.files(\n    new_directory,\n    pattern = paste0(file_extension),\n    all.files = FALSE,\n    full.names = TRUE,\n    recursive = FALSE,\n    include.dirs = FALSE\n  )\n\n# first create a new directory to add the overlay images to\ndir.create(paste0(new_directory, \"/with_overlay/\"))\n\nfor (t in 1:length(files_lst)) {\n  background_image &lt;- magick::image_read(files_lst[t])\n  overlay &lt;-\n    magick::image_read(overlay_file)\n  image_dir &lt;- dirname(files_lst[t])\n  overlay_image_dir &lt;- paste0(image_dir, \"/with_overlay/\")\n  new_filename &lt;-\n    paste0(overlay_image_dir,\n           basename(tools::file_path_sans_ext(files_lst[t])),\n           \"_with_overlay.jpg\")\n  print(paste0(\"Adding Overlay to create: \", new_filename))\n  img &lt;- c(background_image, overlay) %&gt;%\n    magick::image_flatten(.) %&gt;%\n    magick::image_write(., new_filename, format = \"jpg\")\n}"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#generate-kml",
    "href": "goproMaxStills2KmzConverter.html#generate-kml",
    "title": "gopro max stills 2 kmz converter",
    "section": "Generate KML",
    "text": "Generate KML\nThis code generates a google earth kml file linking to the image files in the folder generated above. It uses ExifTool with a template “kml_hide_rollover.fmt” to create the kml file.\n\n\nShow the code\nif (!exists(\"directory\")) {\n  directory &lt;-\n    tcltk::tk_choose.dir(default = \"\", caption = \"Select directory with files to process\")\n  #OR\n  #directory &lt;- \"C:/folder_path_to_gopro_files/\"\n}\n\n# if it doesn't exist then add the default metres between images\nif (!exists(\"metresBetweenEachImageWanted\")) {\n  metresBetweenEachImageWanted &lt;- 50\n}\n\nnew_directory &lt;-\n  paste0(directory,\n         \"_Frames_\",\n         metresBetweenEachImageWanted,\n         \"m_apart/with_overlay\")\n\noutput_kml &lt;-\n  paste0(directory,\n         \"_Frames_\",\n         metresBetweenEachImageWanted,\n         \"m_apart_with_overlay.kml\")\n\nexif_args &lt;- c(\"-p\", \"kml_hide_rollover.fmt\", \"-r\")\nexif_call(\n  args = exif_args,\n  path = new_directory,\n  stdout = output_kml,\n  quiet = FALSE\n)\n\n# now fix the links to the images to make them relative.\nmystring &lt;- readr::read_file(output_kml)\npath_only &lt;- paste0(dirname(output_kml))\nmystring2 &lt;- gsub(path_only, \".\", mystring, fixed = T)\n\nsink(paste0(output_kml))\n  writeLines(mystring2)\nsink()"
  },
  {
    "objectID": "goproMaxStills2KmzConverter.html#convert-kml-images-into-a-kmz",
    "href": "goproMaxStills2KmzConverter.html#convert-kml-images-into-a-kmz",
    "title": "gopro max stills 2 kmz converter",
    "section": "Convert kml & images into a kmz",
    "text": "Convert kml & images into a kmz\nThis code reads the .kml file created above and converts it to a .kmz file. This involves zipping up the images and the .kml file into one file. It also edits the relative links etc. The convenience of the kmz file is that it combines the kml and associated images into one file.\n\n\nShow the code\nlibrary(zip)\n\nif (!exists(\"directory\")) {\n  directory &lt;-\n    tcltk::tk_choose.dir(default = \"\", caption = \"Select directory with files to process\")\n  #OR\n  #directory &lt;- \"C:/folder_path_to_gopro_files/\"\n}\n\nif (!exists(\"metresBetweenEachImageWanted\")) {\n  metresBetweenEachImageWanted &lt;- 100\n}\n\nnew_directory &lt;-\n  paste0(directory,\n         \"_Frames_\",\n         metresBetweenEachImageWanted,\n         \"m_apart/with_overlay\")\n\noutput_kml &lt;-\n  paste0(directory,\n         \"_Frames_\",\n         metresBetweenEachImageWanted,\n         \"m_apart_with_overlay.kml\")\n\nprint(\"Generating kmz file for:\")\nprint(output_kml)\n\nkml_file_name &lt;- basename(output_kml)\nkml_image_directory &lt;- new_directory\n\ndir_to_copy &lt;- kml_image_directory\ntemp_folder &lt;- paste0(usefun::get_parent_dir(directory), \"/temp\")\nnew_dir_path &lt;- paste0(temp_folder, \"/files/\")\nfs::dir_copy(dir_to_copy, new_dir_path, overwrite = TRUE)\nfs::file_copy(output_kml, temp_folder, overwrite = TRUE)\nfile.rename(\n  from = file.path(temp_folder, kml_file_name),\n  to = file.path(temp_folder, \"doc.kml\")\n)\n\n#clean up all of the extra line breaks in the kml file\nmystring &lt;- readr::read_file(file.path(temp_folder, \"doc.kml\"))\nmystring2 &lt;- gsub('\\r\\r\\r\\r\\r\\n', '\\n', mystring, fixed = T)\nmystring3 &lt;- gsub('\\r\\r\\r\\r\\n', '\\n', mystring2, fixed = T)\nmystring4 &lt;- gsub('\\r\\r\\r\\n', '\\n', mystring3, fixed = T)\nmystring5 &lt;- gsub('\\r\\r\\n', '\\n', mystring4, fixed = T)\nmystring6 &lt;- gsub('\\n\\r\\n', ' ', mystring5, fixed = T)\n\n# Extract the part of the string after the last '/'\nlast_part_dir &lt;- tail(strsplit(new_directory, \"/\")[[1]], 2)\nmykml &lt;-\n  stringr::str_replace_all(mystring6[1], paste0(\"src='./\", last_part_dir[1],\"/\", last_part_dir[2]), \"src='files\")\n\nmykml &lt;- stringr::str_replace_all(mykml[1], \"&lt;name&gt;./\", \"&lt;name&gt;\")\nsink(paste0(file.path(temp_folder, \"doc.kml\")))\nwriteLines(mykml)\nsink()\n\n# name for new kmz file\nkmz_file_name &lt;-\n  paste0(usefun::get_parent_dir(directory),\n         \"/\",\n         basename(tools::file_path_sans_ext(output_kml)),\n         \".kmz\")\n\n# create the kmz file\nmyWd &lt;- temp_folder\nfiles_lst &lt;-\n  list.files(\n    path = temp_folder,\n    pattern = \"*.jpg|*.kml\",\n    all.files = FALSE,\n    full.names = FALSE,\n    recursive = TRUE,\n    ignore.case = FALSE,\n    include.dirs = FALSE\n  )\n\n# zip the file up\nzip::zip(\n  kmz_file_name,\n  files_lst,\n  recurse = TRUE,\n  compression_level = 9,\n  include_directories = TRUE,\n  root = myWd,\n  mode = \"mirror\"\n)\n\n# remove the temp folder and its contents\nunlink(temp_folder, recursive = TRUE)"
  }
]